## fs模块下的Stream流

>流是用于在 Node.js 中处理流数据的抽象接口。 流是用于在 Node.js 中处理流数据的抽象接口。 

简单的文件读取操作：

```js
var fs =require('fs');
var readerStream = fs.createReadStream('input.txt');
// 设置编码为 utf8。
readerStream.setEncoding('UTF8');

// 处理流事件 --> data, end, and error
readerStream.on('data', function(chunk) {
   data += chunk;
});

readerStream.on('end',function(){
   console.log(data);
});

```

## Cors的简单请求和复杂请求

**简单请求**须满足以下条件：

* 请求方式为 HEAD、GET、POST

* http头信息不超出以下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain)

**为什么分简单请求和负责请求？ 因为 服务器对这两种请求的处理方式不一样 。**

**复杂请求**

* 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT / DELETE,或者Content-Type字段的类型是application/json。
* 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求
* 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

* **Access-Control-Request-Method ** 用来列出浏览器的CORS请求会用到哪些HTTP方法， 如 put  
* **Access-Control-Request-Headers**  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

**预检请求的回应**

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

## webpack的打包原理

> Webpack是一个前端资源加载/打包工具，它将根据模块的依赖关系进行静态分析，然后将这些资源按照指定的规则生成静态资源。

注意：Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。

### webpack核心概念

1. entry:  一个可执行模块或库的入口文件
2. output:  告诉webpack在哪里输出它所创建的bundles以及如何命名这些文件
3. module: 模块，在webpack里一切皆模块，一个模块对应着一个文件 
4. chunk: 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组成一个chunk.体现了webpack的打包机制
5. loader: 文件转换器，例如把es6转换成es5  scss 转换成css
6. plugin: 插件，用于扩展webpack的功能。

### webpack的作用

1. 模块打包。可以将不同模块的文件打包整合在一起。并且保证他们之间的引用正确，执行有序。
2. 编译兼容。 通过`webpack`的`Loader`机制进行编译转换诸如`.less, .vue, .jsx`这类在浏览器无法识别的格式文件。更好的兼容
3. 能力扩展。通过webpack的`plugin`机制，我们在实现模块化打包和编译兼容的基础上，进行实现诸如按需加载，代码压缩等一系列功能。

### webpack的打包运行原理？

1. 读取`webpack`的配置参数
2. 启动webpack,创建`Compiler`对象并开始解析项目；
3. 从入口文件`entry`开始，并且找到其导入的依赖模块，递归遍历分析，行程依赖关系树；
4. 对不同文件类型的依赖模块文件使用对应的`Loader`进行编译，最终转为js文件；
5. 整个过程中webpack会通过`发布订阅模式`，向外抛出一些 `hooks`，而`webpack`的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。

## 单点登录和多点登录

### 单点登录

> SSO单点登录概念：在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录。

SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，**各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证**。

**需解决的问题：**

1. 解决如何产生和存储信任
2. 系统如何验证这个信任的有效性

解决方案：

1. **以Cookie作为凭证媒介，通过JSONP实现**
   用户登录父应用系统后，跟Session匹配的Cookie会存到客户端中，当用户登录子应用系统时，**授权应用访问父应用提供的JSONP接口，并在请求中**
   **带上父应用系统域名下Cookie，**父应用接收到请求，验证用户的登录状态，
   如果登录中则返回加密信息，子应用通过解析返回加密信息验证，验证通过则登录成功子应用系统
   如果不是登录中则返回重新登录页面![img](../img/786645-20200121175331859-301586919.png)
2. 通过页面重定向的方式
   通过父应用和子应用来回重定向进行通信实现信息安全传递。**父应用提供一个GET方式登录接口，用户通过子应用重定向连接方式访问这个接口**。如果用户还没有登录则返回登录页面，
   如果用户登录了则生成加密的Token并且重定向到子应用提供验证Token的接口，通过解密校验后，登录当前用户![img](../img/786645-20200121175345102-866782122.png)

### 多点登录 

> 同一账号可以在不同终端同时登录，同时收发信息。例如PC端微信和手机微信同时登录。

多点登录限制（禁止用户多点在线）： 一个端同一个账号只能登录一个实例，例如一个账号在网站端登录后，后一个人使用这个账号在网站端 登录，前一个人会被挤下去并会收到通知：“你已在别处登录.. " 

## 图片加载优化

1. 不用图片，能用css代替一些修饰类图片则代替
2. 对于移动端来说，图片质量要求不高，可以把图片放到CDN加载，可以计算出适配屏幕的宽度，然后去请求响应裁剪好的图片
3. 小图使用`base64`格式
4. 将多个图标文件整合到一张图片   `background` 定位访问图标
5. 选择正确的图片格式;
   * 对于能够显示`WebP`格式的浏览器尽量使用 WebP格式。因为WebP格式具有更好的图片压缩算法。能带来更小得图片体积。
   * 小图使用`PNG` , 图标之类的可以用SVG来代替
   * 照片使用`JPEG`

## 其他文件优化

1. css文件放在 `head` 中 
2. 服务端开启文件压缩功能。 webpack vue-cli 
3. 将`script` 标签放在`body`底部，因为js文件执行会阻塞渲染。当然也可以把script标签放在任意位置然后加上`defer` ，表示该文件会并行下载。
4. 执行JS代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑用 `WebWorker`。它可以让我们**另开一个线程执行脚本 而不影响渲染**。

## MySQL 内联、左联、外联的区别 

> 在关系型数据库中如Mysql中，我们有时需要多表查询，从多个表中提取数据， 你可以用SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。

JOIN按照功能大致分为如下三类：

1. INNER JOIN 内连接 ： 获取两个表中字段匹配关系的记录。
2. LEFT JOIN（左联）：先返回左表的所有行，再加上符合连接条件的匹配行
3. RIGHT JOIN（右联）：先返回右表的所有行，再加上符合连接条件的匹配行

### INNER JOIN

> **仅将两个表中满足连接条件的行组合起来作为结果集。** 

格式：  SELECT 列名表 FROM 表名1 [INNER] JOIN 表名2 ON或WHERE 条件表达式 

![image-20211015100241505](https://gitee.com/youngstory/images/raw/master/img/image-20211015100241505.png)

### LEFT JOIN

>会读取左边数据表的全部数据，即便右边表无对应数据。

格式：  SELECT 列名表 FROM 表名1 LEFT JOIN 表名2  ON 条件表达式 

![image-20211015101225627](https://gitee.com/youngstory/images/raw/master/img/image-20211015101225627.png)

### RIGHT JOIN

>会读取右边数据表的全部数据，即便左边边表无对应数据。

格式： SELECT 列名表 FROM 表名1 LEFT JOIN 表名2  ON 条件表达式 

![image-20211015101339217](https://gitee.com/youngstory/images/raw/master/img/image-20211015101339217.png)