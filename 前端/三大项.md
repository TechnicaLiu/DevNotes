# HTML

## WebWorker

>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

### 检测浏览器是否支持web worker

在创建 web worker 之前，请检测用户的浏览器是否支持它：

```js
if(typeof(Worker)!=="undefined")
{
    // 是的! Web worker 支持!
    // 一些代码.....
}
else
{
    //抱歉! Web Worker 不支持
}
```

### 创建 web worker 文件

在外部创建一个javascript脚本 名为demo：

```js
 //  postMessage(i); 用于向html页面传回一段消息。

var i = 0;

function timedCount() {
  i = i + 1;
  postMessage(i);
  setTimeout("timedCount", 500);
}
timedCount();
```

### HTML中使用

`onmessage` 用来监听接收数据，`terminate` 用来终止webworker，释放浏览器/计算机资源

```html
<body>
  <p>计数： <output id="result"></output></p>
  <button onclick="startWorker()">开始工作</button>
  <button onclick="stopWorker()">停止工作</button>

  <script>
    var w;
    function startWorker() {
      if (typeof (Worker) !== "undefined") {  // 判断浏览器是否支持worker 
        if (typeof (w) == "undefined") {
          w = new Worker("demo.js");  // 创建worker对象  
          w.onmessage = function (event) {
            document.getElementById("result").innerHTML = event.data;

          };
        } else {
          document.getElementById("result").innerHTML = "此浏览器不支持webworker功能"
        }
      }
    }

    function stopWorker() {
      w.terminate();   
      w = undefined;
    }
  </script>
</body>
```

### 注意事项

由于 web worker 位于外部文件中，它们无法访问下列 JavaScript 对象：

- window 对象
- document 对象
- parent 对象

# CSS

## SCSS

> CSS预处理器，完全兼容CSS3的同时继承了Sass强大的动态功能。SASS提供的变量、嵌套、混合、继承等特性

node环境下安装使用   `npm install -g sass`

### 变量

你可以利用变量来存储一个你重复使用的 样式 ， 如颜色、font stacks , 或者是你想存储的任何值。

```css
// SCSS
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}

// 编译后
body {
  font: 100% Helvetica, sans-serif;
  color: #333;
}
```

### 嵌套

Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，避免了重复输入父选择器 

```css
nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}

// 编译后 
nav ul {
  margin: 0;
  padding: 0;
  list-style: none; }
nav li {
  display: inline-block; }
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none; }
```

### 引入

SASS 能够将代码分割成 多个片段，并以下划线作为其命名前缀 (_reset.scss），使用 @import 'reset ' 导入的时候不会将其编译成 css文件，不会发生 http 请求，只是将代码块导入合并操作。

```css
// _reset.scss
html, body, ul, ol {
  margin:  0;
  padding: 0;
}

// base.scss
@import 'reset';
body {
  font: 100% Helvetica, sans-serif;
  background-color: #efefef;
}
```

### 混合Mixin 

混合用来分组那些需要在页面中复用的 CSS声明，开发人员可以通过向 mixin 传递变量，来让代码更加灵活。如 在添加浏览器兼容性前缀的时候。

```css
@mixin border-radius($radius) {
          border-radius: $radius;
      -ms-border-radius: $radius;
     -moz-border-radius: $radius;
  -webkit-border-radius: $radius;
}

.box {
  @include border-radius(10px);   // 通过 @include 来使用 定义好的 mixin 
}
```

### 继承

可以通过 `@extend` 指令在选择器之间复用CSS属性，不会产生冗余的代码

```scss
// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。
%other-styles {
  display: flex;
  flex-wrap: wrap;
}

// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。
%message-common {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-common;
}

.success {
  @extend %message-common;
  border-color: green;
}

.error {
  @extend %message-common;
  border-color: red;
}

.warning {
  @extend %message-common;
  border-color: yellow;
}
```

编译后

```scss
.message .success .error .warning {
	border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}
.success {
  border-color: green;
}
.error {
  border-color: red;
}
.warning {
  border-color: yellow;
}
```

### 操作符

SASS提供了标准的`算术运算符`，例如+、-、*、/、%。

```scss
.container { width: 100%; }

article[role="main"] {
  float: left;
  width: 600px / 960px * 100%;
}

aside[role="complementary"] {
  float: right;
  width: 300px / 960px * 100%;
}
```

编译后 

```scss
.container {
  width: 100%; }

article[role="main"] {
  float: left;
  width: 62.5%; }

aside[role="complementary"] {
  float: right;
  width: 31.25%; }
```

### 扩展

#### 引用父级选择器 & 

```swift
/*===== SCSS =====*/
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}

/*===== CSS =====*/
a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }
```

#### 嵌套属性

CSS 许多属性都同属于同一个命名空间，如font-size、font-weight 等 都属于font 空间下 ，我们可以 font `：`来定义  

```
// 注意用 : 来定义 
.demo{
	font:{
		size:30em;
		family:fantasy;
		weight:bold;
	}
}

// 编译后 
.demo {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; 
 }
```

### 支持if  elseif   for循环 等语句

```js
@mixin txt($weight) { 
  color: white; 
  @if $weight == bold { 
    font-weight: bold;
  } 
  @else if $weight == light { 
    font-weight: 100;
  } 
  @else { 
    font-weight: normal;
  } 
}

.txt1 { 
  @include txt(bold); 
}

// 编译后 
.txt1{
	color:white;
	font-weight:bold ;
}
```



## LESS

Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数.  Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。

### 与sass的区别

1. 变量符不一样  **less 是 @  , 而scss是 $** 
2. 不支持 if  elseif  语句 
3. 引入与普通的css 的引入无差异

# JS

## 值、类型

### null和undefined

null 常用来 描述"空值" ，它可以表示数字，字符串和对象是“无值的”； typeof null 返回object ，可以认为是一个 特殊的对象值。

undefined  表示变量未初始化，未定义， 如 函数无返回值  两者都表示“值的空缺"  所以 **null == undefined** , 但是严格模式 **null === undefined 为false** 

### 包装对象

字符串本身没有属性，但只要引用了字符串的属性，js就会将字符串通过调用 new String（）的方式转换成对象，这个对象就继承了字符串的方法 ，并被用来出来属性的引用，一旦属性引用结束，这个新创建的对象就会销毁。

### 不可变原始值和可变的对象引用

原始值（undefined、null、布尔值、数字和字符串)是不可更改的。值相等时才相等

对象(数组/函数) **值是可更改的**，两个对象比较即使他们属性相同值相同，但不等。只有他们 引用的是 同一个基对象，才相等。

```js
var a=[];
var b=a;
b[0] =1;
a[0]   // 1 
a === b   // true 因为他们引用的是同一个数组 
```

## 表达式和运算符

### 属性访问表达式

常用于得到一个对象属性或一个数组元素的值 。如 a.b    a['b']/a[1]

使用 . identifer 的方式 要注意仅适用于 要访问的属性名称是合法的标识符，并且需要知道属性名称 。

使用 [ ] 的方式  ： 属性名称是一个保留字/ 包含空格和标点符号，或是一个数字（数组中的索引）或者  属性名是通过运算得出的值不是固定值时。

## 语句

### switch 

> 适合 进行多条件判断的 场景  

注意的是 ： 

1. case语句没有名字，只和后面的语句关联在一起。 也就是拿 expression的值 和 case后的表达式进行判断。  default语句是 无匹配的case时执行的。

2. 如果 case 中的语句不写 break ；则他会一直向下执行，并且执行default 语句 ；

```js
 let n = 1 + 2;
    switch (n) {
      case 1:
        console.log('n=' + n)
      case 2:
        console.log('n=' + n)
      case 3:
        console.log('n=' + n)
      default:
        console.log('无匹配项')
    }
    // n=3   '无匹配项'
```

### throw

> 当产生运行时错误或者程序使用throw语句时就会显式的抛出异常 。

js解释器抛出异常的时候通常采用 Error类型和其他子类型，我们可以使用他们。

```
function(x){
	if(x<0) throw new Error('x不能是负数');
}
```

当抛出异常时，js解释器会立即停止当前正在执行的逻辑。

### try/catch/finally

try语句定义了需要处理的异常所在的代码块 

catch 从句跟随其后，当try 语句报错，调用cathc内的代码逻辑。

finally 中的语句 无论try语句是否报异常都会执行。

```js
try{
	//如有异常，要么由throw语句抛出或者调用一个方法间接抛出 
}
catch(e){
	// 主要这里有个参数,用来接收错误 
}
finally{
 	/*
 		终止try语句的方式有 ：
 		1. 正常终止，执行完语句块的最后一条语句
 		2. 通过break、continue/ return 语句终止
 		3. 抛出一个异常，异常被catch从句捕获
 		4. 抛出一个异常，异常未被捕获，继续向上传播 
 	*/
}
```

## 对象

### 创建对象

Object.create( )  括号中用来存放 创建新对象的原型 

```js
var o1 = Object.create({x:1,y:2})  //o1继承了属性x和y
```

如果参数为 null 则代表创建一个没有原型的新对象，即不继承任何东西 包括 基础方法 toString 

如果想创建一个普通的空对象  可以这么写 `Object.create(Object.prototype)`   效果和 new Object  /  {  } 一样

### 属性的查询

可以通过 点. 或者 方括号 [ ] 运算符来获取属性的值。

**区别：**

对于点.来说，右侧必须是一个以属性名称命名的简单标识符。对于 方括号来说，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字。

方法： Object.keys( ) 

用于返回指定对象的属性 组成的数组。

```js
 var obj = {
      name: 'abin',
      age: 18,
      gender: '男'
    }
    var keys = Object.keys(obj); // ['name', 'age', 'gender']
```

### 属性访问错误

查询一个不存在的属性不会报错，只会返回undefined ，但是如果对象不存在，那访问该对象的属性就会报错 。 

那如何避免  因对象不存在而报错呢 ？ 两种 方法  用 if 或者用 && 并运算符

```js
// 第一种 
var  len = undefined;
if(book){
  if(book.subtitle)len = book.subtitle.length;
}

// 第二种 
var len = book&&book.subtitle&&book.subtitle.length;
```

### 删除属性

delete运算符可以删除对象的属性 (自身属性) ， 不能删除继承属性 

```
delete book.author // book不再有属性 author 
```

### 检测属性

判断某个属性是否存在于某个对象中 。 可以通过三种方法。

1. in运算符

   如果对象的**自有属性或继承属性中**包含这个属性则返回 true  

   ```js
   var o = {x:1}  
   "x" in o ; // true  “x”是o的属性
   “y” in o ; // false   y不是o的属性
   ‘toString’ in o;  // true  o继承toString 属性
   ```

2. hasOwnProperty ****

   用来检测 给定的名字是否是对象的**自有属性** ，对于 继承属性它将返回false ； 

   ```js
   var o = {x:1}  
   "x" in o ; // true  “x”是o的属性
   “y” in o ; // false   y不是o的属性
   ‘toString’ in o;  // false  o继承toString 属性
   ```

3. propertyIsEnumberable 

   只有检测到是**自身属性且这个属性的可枚举 性 为true** 时，它才返回true 

### 对象方法

1. toString( ) 方法

   无参数，返回一个表示调用这个方法的对象值的字符串，由于默认的toString( )方法并不会输出很多有用的信息，因此很多类都带有自定义的toString( ) 如：

   数组转换为字符串，结果时一个数组元素列表，只是每个元素都转换成了字符串 

   当函数转换为字符串，得到的是函数的源代码。

   ```js
   var s={x:1,y:1}.toString();  //  输出 [object,Object]
   ```

2. toLocaleString(  ) 

   返回一个表示这个对象的本地化字符串。 Object中默认的toLocaleString( ) 方法并不做任何本地化自身的操作仅仅调用toString( ) 方法返回对应值。

   它对 数字、日期、和时间做本地化的转换

   ```js
    let s = new Date();
       console.log(s);  // 2021 08:56:58 GMT+0800 (中国标准时间)
       console.log(typeof s); // object
       console.log(s.toLocaleString());  //2021/12/25 上午8:56:58 
   ```

3. toJSON( )方法

   对于需要执行序列化的对象来说，JSON.stringify( ) 方法会调用toJSON( )方法

4. valueOf( )方法

   类似于 toString( )方法，当JS需要**将对象转换成某种原始值**而非字符串的时候才会调用它。尤其是转换为数字的时候。

   ```js
   //  不同类型对象的 valueOf()方法的返回值
   Array : 返回数组本身
   Boolean : 返回布尔值 
   Date: 返回 从1970年1月1日午夜开始计时的毫秒数 
   Number : 返回数字值
   object : 返回对象本身 
   // Math 和 Error 对象没有 valueOf()
   ```

## 数组

### 删除

删除数组元素  除了  pop shift之外，还可以用 delete 运算符

```js
 var a = [1, 2, 3];
    delete a[1];
    console.log(a);

// 结果  
(3) [1, empty, 3]
0: 1
2: 3
length: 3

// 可以看出 索引为1的元素已经删除，值为undefined, 但是数组的length并没有改变 
```

### 遍历

使用for循环遍历数组  如 将一个对象的值都遍历到数组中

```js
 var obj = {
      name: 'abin',
      age: 18,
      gender: '男'
    }
    var keys = Object.keys(obj);
    console.log(keys);  ['name', 'age', 'gender']
    var resultArr = [];
    for (let i = 0; i < keys.length; i++) {
      let attr = keys[i];
      resultArr[i] = obj[attr]
    }
 console.log(resultArr); // ['abin', 18, '男']
```

假设数组是非稠密数组，即存在 null  undefined 和不存在的值 ，可选择加判断条件 。

如果 想跳过 null  undefined 和不存在的元素， `if( !arr[ i ] ) continue ;` 

如果 想跳过 undefined 的值   `if(a[i] === undefined) continue ;`  

如果只想跳过不存在的元素，而仍然要处理存在的null  undefined  `if( !(i in arr)) continue;`

### 数组方法

1. join(  )

   将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选字符串在生成的字符串中来分隔数组中的每个元素，如不写则默认以逗号分隔。

2. **reverse( )**

   将数组中的元素颠倒顺序，返回逆序的数组。

3. **sort ( )**

   将数组中的元素排序并返回排序后的数组。**若不带参数，则默认以字母顺序排序**。  如果数组中有undefined， 则自动排到最后。

   同时我们可以指定两个参数 a,b 来决定 元素排序方式 从小到大/从大到小 

   ```js
   a.sort(function(a,b){
   	return a-b // 从小到大 
   })
   ```

4. concat（）

   创建并返回一个新数组，将原始数组 和concat（）中的每个参数进行连接。

   需要注意的是 ：concat( ) 不会递归扁平化数组的数组。 且concat不会修改原数组。 

   ```
   var a=[1,2,3];
   a.concat(4,[5,[6,7]])   // 返回 [1,2,3,4,5,[6,7]]  
   ```

5. slice( ) 

   返回指定数组的一个片段或子数组。 他的两个参数分别指定了要截取的开始位置和结束位置。同时，返回的数组不包含结束位置的数值。

   **不会修改原数组**

6. splice  

   不同于 slice , 它可以 插入数据，删除数据，有三个参数，第一个参数指定了 插入和删除的起始位置，第二个参数指定了应该从数组中删除的元素的个数，第三个参数指定了 要插入的元素， 但是重要的一点是  **它会修改原数组** 

## 作为数组的字符串

字符串的行为类似于 只读的数组 ，即我们 可以通过 **方括号[索引]  /  charAt(0)** 来访问单个字符。

通用的数组方法可以应用到字符串上。 如 join  filter 

```js
let s = 'Javascript';
let result = Array.prototype.join.call(s, ' ');// J a v a s c r i p t

let s = 'Javascript';
let result = Array.prototype.filter.call(s, function (x) {
  return x.match(/[^aeiou]/)
}).join(" ");
console.log(result);  // J v s c r p t 

注意！当把字符串当作数组看待时，他们是只读的。如push sort reverse splice 等数组方法会修改数组，他们在字符串上是无效的。
```

## 函数

### 函数名的定义 

**多以 动词或者动词为前缀的词组 来定义函数**，提高代码可读性。

当函数名包含多个单词时，一种情况是 以 下划线 分隔，另一种是  除首个单词外的其他单词 首字母大写。

当函数是内部函数或者私有函数，函数名通常以下划线为前缀。

对于经常调用的函数，我们可以指定短函数名。

## 扩展

### 解构赋值

> 在解构赋值中，等号右侧是一个数组或对象，指定左侧一个或多个变量的语法和右侧的数组和对象直接量的语法保持一致。

常用于 函数返回一组数据时进行解构赋值。

```js
let {a,b} ={a:123,b:456} // 得到变量a为123 ， b为456 
let [x,y] = [1,2] // 等价于 x=1，y=2
```

**在解构赋值中，右侧的的数组中所包含的元素不必和左边的变量一一对应，左侧多余的变量的赋值为undefined,而右侧多余的值则会忽略。**

链式解构赋值：

```js
 let first, second, all;
 all = [first, second] = [1, 2, 3, 4];
 console.log(first, second, all); // first=1  second =2  all =[1,2,3,4]
```

嵌套解构赋值

```js
let [one,[twoA,twoB]] = [1,[2,2.5],3]; 
// one=1,twoA=2,twoB=2.5
```

对象解构赋值 

```js
  let transparent={r:0.0,g:0.0,b:0.0,a:1.1};
  let {r:red,g:green,b:blue} = transparent   // red = 0.0.green=0.0 blue=0.0
```

## 客户端JS

> window对象是所有客户端JavaScript特性和API的主要接入点,表示一个窗口/窗体。 可以用 标识符window来引用它 ！ 

window下的重要属性 ：

1. location 指定当前显示在窗口中的URL

   ```js
   window.location = 'http://baidu.com'
   ```

2. document  文档， 常用于JS操作 DOM 

   ```js
   document.getElementsByClassName('btn')[0];
   ```

3. onload处理函数

   当显示在窗口中的文档内容稳定并可以操作时会触发它！ 

   ```js
   window.onload=function(){
   		// 代码
   }
   ```

### 多窗口和窗体

一个web浏览器窗口可能在桌面上包含多个标签页。每一个标签页都是独立的”浏览上下文，每一个上下文都有独立的window对象，而且相互之间互不干扰。

**打开窗口**

Window.open( )  载入指定的URL到新的或已存在的窗口中，并返回代表那个窗口的Window对象 。

可选参数有4个 ：

1. 要在新窗口显示的文档的URL ，省略则 使用 空白页 about:blank
2. 新打开的窗口的名字。 若该名字存在即直接使用已存在的窗口。省略参数默认 _blank
3. 以逗号分割的列表，包含大小和各种属性 
4. 该参数只在第二个参数命名的是一个存在的窗口时才生效，声明了由第一个参数指定的URL是应用替换掉窗口浏览历史的当前条目（true）,还是在窗口浏览历史中创建一个新的条目（false） 默认为 false 

```js
 window.open('http://www.baidu.com', 'baidu', 'width=400,height=400,status=yes,resizable=yes')
```

**关闭窗口**

window.close( )  

即使一个窗口关闭了，代表它的window对象仍然存在，已关闭的窗口会有个值为true的closed属性，它的document会是null.

### 脚本化文档

**1. 查询元素的几何尺寸**

**使用getBoundingClientRect**()  可以判定一个元素的尺寸和位置 。 

![image-20211228104157444](https://gitee.com/youngstory/images/raw/master/img/202112281041534.png)

其中： left 和 top 表示元素的左上角的X和Y坐标，right和bottom 表示元素的右下角的X和Y坐标 

**2.滚动** 

滚动浏览器到文档最下面的页面可见：

```js
// 获取文档和视口的高度 
let documentHeight = document.documentElement.offsetHeight;
let viewportHeigth = window.innerHeight;
window.scrollTo(0, documentHeight - viewportHeigth)
```

