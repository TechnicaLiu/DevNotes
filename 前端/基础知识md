# HTML

## WebWorker

>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

### 检测浏览器是否支持web worker

在创建 web worker 之前，请检测用户的浏览器是否支持它：

```js
if(typeof(Worker)!=="undefined")
{
    // 是的! Web worker 支持!
    // 一些代码.....
}
else
{
    //抱歉! Web Worker 不支持
}
```

### 创建 web worker 文件

在外部创建一个javascript脚本 名为demo：

```js
 //  postMessage(i); 用于向html页面传回一段消息。

var i = 0;

function timedCount() {
  i = i + 1;
  postMessage(i);
  setTimeout("timedCount", 500);
}
timedCount();
```

### HTML中使用

`onmessage` 用来监听接收数据，`terminate` 用来终止webworker，释放浏览器/计算机资源

```html
<body>
  <p>计数： <output id="result"></output></p>
  <button onclick="startWorker()">开始工作</button>
  <button onclick="stopWorker()">停止工作</button>

  <script>
    var w;
    function startWorker() {
      if (typeof (Worker) !== "undefined") {  // 判断浏览器是否支持worker 
        if (typeof (w) == "undefined") {
          w = new Worker("demo.js");  // 创建worker对象  
          w.onmessage = function (event) {
            document.getElementById("result").innerHTML = event.data;

          };
        } else {
          document.getElementById("result").innerHTML = "此浏览器不支持webworker功能"
        }
      }
    }

    function stopWorker() {
      w.terminate();   
      w = undefined;
    }
  </script>
</body>
```

### 注意事项

由于 web worker 位于外部文件中，它们无法访问下列 JavaScript 对象：

- window 对象
- document 对象
- parent 对象

## SVG

> SVG(可缩放矢量图形) 是一个由XML定义的文件，所以可以用任何文本编辑器创建。

### 什么是SVG?

SVG 使用 XML格式来定义图像，在放大或改变尺寸的情况下其图形质量不会有所损失。同时他也存在以下优势：

1. SVG与JPEG和GIF图像比起来，尺寸更小，且可压缩性更强。
2. SVG可在图像质量不下降的情况下被放大。
3. SVG 文件是纯粹的 XML。

### 示例

```xml
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="red" />
</svg>

```

效果：

<img src="https://gitee.com/youngstory/images/raw/master/img/202201111409769.png" alt="image-20220111140925478" style="zoom: 50%;" />

代码解析：

* `<xml>`第一行包含了 XML 声明。

* standalone 属性规定此 SVG 文件是否是"独立的"，或含有对外部文件的引用，standalone="no" 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。
* `<svg></svg>是表示SVG代码，相当于开始标签和结束标签，这是根元素。`

* width和height属性可设置此 SVG文档的宽度和高度。
* version属性可定义所使用的SVG版本。
* xmlns 属性可定义SVG命名空间。
* `<circle> `用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。

* stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。

* fill 属性设置形状内的颜色。我们把填充颜色设置为红色。

* 关闭标签的作用是关闭 SVG 元素和文档本身。

### 应用场景

**ICON图标**

摆脱了以往 通切各种倍数的图来适配高清设备的束缚，因为svg图像放大多少倍质量都不会变

<img src="https://gitee.com/youngstory/images/raw/master/img/202201111425222.png" alt="image-20220111142549125" style="zoom:80%;" />

同时我们可以通过改变他的属性来轻松的给他更换颜色 。

**ICOM Morphing动画** 

所谓Morphing动画是表示，同一个模型，从一个形状变到另一个形状。这种动画交互会更加的细腻。

**在文字中的应用**

如通过代码来实现 渐变文字效果

```js
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1000" height="400"> 

    <title>Applying a gradient background to text in SVG</title> 

    <defs>

       <linearGradient id="filler" x="0%" y="100%">

           <stop stop-color="olivedrab" offset="0%"></stop>

           <stop stop-color="peru" offset="20%"></stop>

           <stop stop-color="goldenrod" offset="40%"></stop>

           <stop stop-color="firebrick" offset="60%"></stop>

           <stop stop-color="thistle" offset="80%"></stop>

           <stop stop-color="sandybrown" offset="100%"></stop>

       </linearGradient>

    </defs>

    <text x="100" y="70%" font-size="205" fill="url(#filler)">ISUX Design</text>

</svg>
```

效果：

![image-20220111144015004](https://gitee.com/youngstory/images/raw/master/img/202201111440141.png)





# CSS

## SCSS

> CSS预处理器，完全兼容CSS3的同时继承了Sass强大的动态功能。SASS提供的变量、嵌套、混合、继承等特性

node环境下安装使用   `npm install -g sass`

### 变量

你可以利用变量来存储一个你重复使用的 样式 ， 如颜色、font stacks , 或者是你想存储的任何值。

```css
// SCSS
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}

// 编译后
body {
  font: 100% Helvetica, sans-serif;
  color: #333;
}
```

### 嵌套

Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，避免了重复输入父选择器 

```css
nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}

// 编译后 
nav ul {
  margin: 0;
  padding: 0;
  list-style: none; }
nav li {
  display: inline-block; }
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none; }
```

### 引入

SASS 能够将代码分割成 多个片段，并以下划线作为其命名前缀 (_reset.scss），使用 @import 'reset ' 导入的时候不会将其编译成 css文件，不会发生 http 请求，只是将代码块导入合并操作。

```css
// _reset.scss
html, body, ul, ol {
  margin:  0;
  padding: 0;
}

// base.scss
@import 'reset';
body {
  font: 100% Helvetica, sans-serif;
  background-color: #efefef;
}
```

### 混合Mixin 

混合用来分组那些需要在页面中复用的 CSS声明，开发人员可以通过向 mixin 传递变量，来让代码更加灵活。如 在添加浏览器兼容性前缀的时候。

```css
@mixin border-radius($radius) {
          border-radius: $radius;
      -ms-border-radius: $radius;
     -moz-border-radius: $radius;
  -webkit-border-radius: $radius;
}

.box {
  @include border-radius(10px);   // 通过 @include 来使用 定义好的 mixin 
}
-------------------------------------------------------------------------------------
@mixin webkit($type, $value) {
    -webkit-#{$type}: $value;
    -moz-#{$type}: $value;
    -o-#{$type}: $value;
    -ms-#{$type}: $value;
    #{$type}: $value;
}
@include webkit(transition, all .3s ease 0s);

```

### 继承

可以通过 `@extend` 指令在选择器之间复用CSS属性，不会产生冗余的代码

```scss
// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。
%other-styles {
  display: flex;
  flex-wrap: wrap;
}

// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。
%message-common {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-common;
}

.success {
  @extend %message-common;
  border-color: green;
}

.error {
  @extend %message-common;
  border-color: red;
}

.warning {
  @extend %message-common;
  border-color: yellow;
}
```

编译后

```scss
.message .success .error .warning {
	border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}
.success {
  border-color: green;
}
.error {
  border-color: red;
}
.warning {
  border-color: yellow;
}
```

### 操作符

SASS提供了标准的`算术运算符`，例如+、-、*、/、%。

```scss
.container { width: 100%; }

article[role="main"] {
  float: left;
  width: 600px / 960px * 100%;
}

aside[role="complementary"] {
  float: right;
  width: 300px / 960px * 100%;
}
```

编译后 

```scss
.container {
  width: 100%; }

article[role="main"] {
  float: left;
  width: 62.5%; }

aside[role="complementary"] {
  float: right;
  width: 31.25%; }
```

### 扩展

#### 引用父级选择器 & 

```swift
/*===== SCSS =====*/
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}

/*===== CSS =====*/
a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }
```

#### 嵌套属性

CSS 许多属性都同属于同一个命名空间，如font-size、font-weight 等 都属于font 空间下 ，我们可以 font `：`来定义  

```
// 注意用 : 来定义 
.demo{
	font:{
		size:30em;
		family:fantasy;
		weight:bold;
	}
}

// 编译后 
.demo {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; 
 }
```

### 支持if  elseif   for循环 等语句

```js
@mixin txt($weight) { 
  color: white; 
  @if $weight == bold { 
    font-weight: bold;
  } 
  @else if $weight == light { 
    font-weight: 100;
  } 
  @else { 
    font-weight: normal;
  } 
}

.txt1 { 
  @include txt(bold); 
}

// 编译后 
.txt1{
	color:white;
	font-weight:bold ;
}
```



## LESS

Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数.  Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。

### 与sass的区别

1. 变量符不一样  **less 是 @  , 而scss是 $** 
2. 不支持 if  elseif  语句 
3. 引入与普通的css 的引入无差异

# JavaScript

## let命令和const命令

### let命令

#### 暂时性死区 

只要块级作用域内存在 let 和 const命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。

在代码块内，使用let命令声明变量之前，该变量是不可用的。称为：“暂时性死区”

举例：

```js
var  tmp = 123;
if(true){
  tmp = 'abc'; // 不受外界影响  ReferenceError
  let tmp 
  console.log(tmp) // undefined  暂时性死区 
}
```

#### 不允许重复声明

在同一个作用域内，let不允许重复声明同一个变量 。

```js
// 报错 
function(){
  let a = 1;
  let a = 10 ; 
}
```

### const命令

> const 声明一个只读的常量，一旦声明，常量的值就不能改变。

需要注意的是：

1. const 一旦 声明变量，就必须立即初始化。不能先声明后赋值
2. const 同样 不存在变量提升， 具有暂时性死区。

const 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于**简单型数据，其值就保存在内存地址中**，因此等同于常量， 而对于**复合类型的数据，变量指向的内存地址保存的只是一个指针**，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。

```js
const foo ={};
foo.prop = 123;
foo.prop // 123  

foo ={} // 报错，因为指向了另一个对象 ，同理数组也是一样的 
```

如果真的想将对象冻结，可以使用 Object.freeze方法.

```js
const foo = Object.freeze( { } );
// 常规模式下，下面一行不起作用 ；
// 严格模式下，该行会报错
foo.prop=123 ;
```

### 顶层对象的属性

顶层对象在浏览器中指的是window对象，在Node环境中指的是 global对象。

在ES5中，顶层对象的属性与全局变量是等价的。存在潜在的副作用，如顶层对象的属性是到处都可以读写的，不利于模块化编程，其次， window 也有其实体含义 -- 即浏览器对象。

```js
window.a = 1;
a // 1

a = 2 ;
window.a // 2
```

在ES6中，为了规避这些错误，做出了改善：

1. var命令和function命令声明的全局变量依旧是顶层对象的属性
2. let 命令，const命令，class命令声明的全局变量不属于顶层对象的属性。

## 变量的解构赋值

> 在解构赋值中，等号右侧是一个数组或对象，指定左侧一个或多个变量的语法和右侧的数组和对象直接量的语法保持一致。

常用于 函数返回一组数据时进行解构赋值。

```js
let {a,b} ={a:123,b:456} // 得到变量a为123 ， b 为456 
let [x,y] = [1,2] // 等价于 x=1，y=2
```

**在解构赋值中，右侧的的数组中所包含的元素不必和左边的变量一一对应，左侧多余的变量的赋值为undefined,而右侧多余的值则会忽略。** 

### 链式解构赋值

```js
 let first, second, all;
 all = [first, second] = [1, 2, 3, 4];
 console.log(first, second, all); // first=1  second =2  all =[1,2,3,4]
```

### 嵌套解构赋值

```js
let [one,[twoA,twoB]] = [1,[2,2.5],3]; 
// one=1,twoA=2,twoB=2.5
```

### 对象解构赋值 

```js
  let transparent={r:0.0,g:0.0,b:0.0,a:1.1};
  let {r:red,g:green,b:blue} = transparent   // red = 0.0.green=0.0 blue=0.0
```

### 字符串的解构赋值

字符串在解构赋值的同时，会被转换了类数组的对象 。

```js
const [a,b,c,d] = 'hello'
a // 'h'
b // 'e'
c // 'l'
d // 'l'

```

类数组都有一个length属性，我们可以对这个属性进行解构

```js
let {length : len} = 'hello'
len // 5 
```

### 函数参数的解构赋值

函数的参数也可以使用解构赋值。

```js
function add([x,y]){
  return x+y;
}
add([1,2])  // 3
```

函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y 。

```js
[[1,2],[3,4]].map(([a,b])=> a+b)
 // [3,7]
```

函数参数的解构也可以使用默认值

```js
function move({x=0,y=0} = {}){
  return [x,y];
}
move({x:3,y:8})  // [3,8]
move(); // [0,0]
```

以上函数中，参数是一个对象，通过对对象进行解构，得到x和y的值。如果没有传参，就使用默认的变量值

### 用途

#### 交换变量

```js
let x = 1 ;
let y = 2 ;
[x,y] = [y,x] ;
```

#### 从函数返回多个值

从函数返回多个值我们习惯于将它包装到一个数组/对象上。我们可以解构出他们的值

```js
// 解构返回的数组， 对象同理 
function example(){
  return [1,2,3]
}
let [a,b,c] = example() 
a // 1 
b// 2
c // 3 
```

#### 函数参数的定义

解构赋值可以方便地将一组参数与变量名对应起来。

```js
// 参数是一组有次序地值
 function f([x, y, z]) {
     ....
  }
 f([1, 2, 3])
// 同时也支持无次序地参数 
```

#### 提取JSON数据

```js
 let jsonData = {
      id: 42,
      myname: 'Abin',
      hobby: ['basketball', 'volleyball']
    }
    let {
      id,
      myname,
      hobby
    } = jsonData;
console.log(id, myname, hobby);
// 42 'Abin'  ['basketball', 'volleyball']

```

#### 函数参数的默认值

```js
$.ajax=function(url,{
  async=true,
  beforesend=function(){},
  cache = true
}){
  // .. do stuff
}
```

#### 遍历Map解构

任何部署了Iterator接口的对象都可以用 for .. of 循环遍历。Map结构支持 Iterator接口，我们可以通过解构 来 拿到 它的键和值。

```js
var map = new Map();
    map.set('first', 'hello');
    map.set('second', 'world');
    for (let [key, value] of map) {
      console.log(key + ' is ' + value);  // 输出 它的 键  和 值
    }   
    for (let [key] of map) {
      console.log(key);  // 输出 它的 键 
    }
    for (let [, value] of map) {  
      console.log(value);  //输出 它的 值
    }
```

#### 输入模块的指定方法

加载模块式，我们可以通过解构来指定我们需要的方法

```js
const {SourceMapConsumer,SouceNode} = require("souce-map")
```





## 值、类型

### null和undefined

null 常用来 描述"空值" ，它可以表示数字，字符串和对象是“无值的”； typeof null 返回object ，可以认为是一个 特殊的对象值。

undefined  表示变量未初始化，未定义， 如 函数无返回值  两者都表示“值的空缺"  所以 **null == undefined** , 但是严格模式 **null === undefined 为false** 

### 包装对象

字符串本身没有属性，但只要引用了字符串的属性，js就会将字符串通过调用 new String（）的方式转换成对象，这个对象就继承了字符串的方法 ，并被用来出来属性的引用，一旦属性引用结束，这个新创建的对象就会销毁。

### 不可变原始值和可变的对象引用

原始值（undefined、null、布尔值、数字和字符串)是不可更改的。值相等时才相等

对象(数组/函数) **值是可更改的**，两个对象比较即使他们属性相同值相同，但不等。只有他们 引用的是 同一个基对象，才相等。

```js
var a=[];
var b=a;
b[0] =1;
a[0]   // 1 
a === b   // true 因为他们引用的是同一个数组 
```

## 表达式和运算符

### 属性访问表达式

常用于得到一个对象属性或一个数组元素的值 。如 a.b    a['b']/a[1]

使用 . identifer 的方式 要注意仅适用于 要访问的属性名称是合法的标识符，并且需要知道属性名称 。

使用 [ ] 的方式  ： 属性名称是一个保留字/ 包含空格和标点符号，或是一个数字（数组中的索引）或者  属性名是通过运算得出的值不是固定值时。

## 语句

### switch 

> 适合 进行多条件判断的 场景  

注意的是 ： 

1. case语句没有名字，只和后面的语句关联在一起。 也就是拿 expression的值 和 case后的表达式进行判断。  default语句是 无匹配的case时执行的。

2. 如果 case 中的语句不写 break ；则他会一直向下执行，并且执行default 语句 ；

```js
 let n = 1 + 2;
    switch (n) {
      case 1:
        console.log('n=' + n)
      case 2:
        console.log('n=' + n)
      case 3:
        console.log('n=' + n)
      default:
        console.log('无匹配项')
    }
    // n=3   '无匹配项'
```

### throw

> 当产生运行时错误或者程序使用throw语句时就会显式的抛出异常 。

js解释器抛出异常的时候通常采用 Error类型和其他子类型，我们可以使用他们。

```
function(x){
	if(x<0) throw new Error('x不能是负数');
}
```

当抛出异常时，js解释器会立即停止当前正在执行的逻辑。

### try/catch/finally

try语句定义了需要处理的异常所在的代码块 

catch 从句跟随其后，当try 语句报错，调用cathc内的代码逻辑。

finally 中的语句 无论try语句是否报异常都会执行。

```js
try{
	//如有异常，要么由throw语句抛出或者调用一个方法间接抛出 
}
catch(e){
	// 主要这里有个参数,用来接收错误 
}
finally{
 	/*
 		终止try语句的方式有 ：
 		1. 正常终止，执行完语句块的最后一条语句
 		2. 通过break、continue/ return 语句终止
 		3. 抛出一个异常，异常被catch从句捕获
 		4. 抛出一个异常，异常未被捕获，继续向上传播 
 	*/
}
```

## 对象

### 创建对象

Object.create( )  括号中用来存放 创建新对象的原型 

```js
var o1 = Object.create({x:1,y:2})  //o1继承了属性x和y
```

如果参数为 null 则代表创建一个没有原型的新对象，即不继承任何东西 包括 基础方法 toString 

如果想创建一个普通的空对象  可以这么写 `Object.create(Object.prototype)`   效果和 new Object  /  {  } 一样

### 属性的查询

可以通过 点. 或者 方括号 [ ] 运算符来获取属性的值。

**区别：**

对于点.来说，右侧必须是一个以属性名称命名的简单标识符。对于 方括号来说，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字。

方法： Object.keys( ) 

用于返回指定对象的属性 组成的数组。

```js
 var obj = {
      name: 'abin',
      age: 18,
      gender: '男'
    }
    var keys = Object.keys(obj); // ['name', 'age', 'gender']
```

### 属性访问错误

查询一个不存在的属性不会报错，只会返回undefined ，但是如果对象不存在，那访问该对象的属性就会报错 。 

那如何避免  因对象不存在而报错呢 ？ 两种 方法  用 if 或者用 && 并运算符

```js
// 第一种 
var  len = undefined;
if(book){
  if(book.subtitle)len = book.subtitle.length;
}

// 第二种 
var len = book&&book.subtitle&&book.subtitle.length;
```

### 删除属性

delete运算符可以删除对象的属性 (自身属性) ， 不能删除继承属性 

```
delete book.author // book不再有属性 author 
```

### 检测属性

判断某个属性是否存在于某个对象中 。 可以通过三种方法。

1. in运算符

   如果对象的**自有属性或继承属性中**包含这个属性则返回 true  

   ```js
   var o = {x:1}  
   "x" in o ; // true  “x”是o的属性
   “y” in o ; // false   y不是o的属性
   ‘toString’ in o;  // true  o继承toString 属性
   ```

2. hasOwnProperty 

   用来检测 给定的名字是否是对象的**自有属性** ，对于 继承属性它将返回false ； 

   ```js
   var o = {x:1}  
   "x" in o ; // true  “x”是o的属性
   “y” in o ; // false   y不是o的属性
   ‘toString’ in o;  // false  o继承toString 属性
   ```

3. propertyIsEnumberable 

   只有检测到是**自身属性且这个属性的可枚举 性 为true** 时，它才返回true 

### 对象方法

1. toString( ) 方法

   无参数，返回一个表示调用这个方法的对象值的字符串，由于默认的toString( )方法并不会输出很多有用的信息，因此很多类都带有自定义的toString( ) 如：

   数组转换为字符串，结果时一个数组元素列表，只是每个元素都转换成了字符串 

   当函数转换为字符串，得到的是函数的源代码。

   ```js
   var s={x:1,y:1}.toString();  //  输出 [object,Object]
   ```

2. toLocaleString(  ) 

   返回一个表示这个对象的本地化字符串。 Object中默认的toLocaleString( ) 方法并不做任何本地化自身的操作仅仅调用toString( ) 方法返回对应值。

   它对 数字、日期、和时间做本地化的转换

   ```js
    let s = new Date();
       console.log(s);  // 2021 08:56:58 GMT+0800 (中国标准时间)
       console.log(typeof s); // object
       console.log(s.toLocaleString());  //2021/12/25 上午8:56:58 
   ```

3. toJSON( )方法

   对于需要执行序列化的对象来说，JSON.stringify( ) 方法会调用toJSON( )方法

4. valueOf( )方法

   类似于 toString( )方法，当JS需要**将对象转换成某种原始值**而非字符串的时候才会调用它。尤其是转换为数字的时候。

   ```js
   //  不同类型对象的 valueOf()方法的返回值
   Array : 返回数组本身
   Boolean : 返回布尔值 
   Date: 返回 从1970年1月1日午夜开始计时的毫秒数 
   Number : 返回数字值
   object : 返回对象本身 
   // Math 和 Error 对象没有 valueOf()
   ```

5. Object.assign(target, source)

   将所有可枚举属性的值从一个或多个源对象分配到目标对象。返回目标对象。

   如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。

   ```js
    let obj = {
         a: 1,
         b: 2
       };
       let obj2 = {
         b: 3,
         d: 4
       };
       Object.assign(obj2, obj);
       console.log(obj2);    // {b: 2, d: 4, a: 1}
   ```

   

## 数组

### Array.from

> 用于将两类对象转为真正的数组，类似数组的对象和可遍历对象。

类似数组的对象: 如DOM操作返回的NodeList集合、函数内部arguments对象 

可遍历对象 ： 如字符串， Set ，Map

```js
// 将NodeList转为真正的数组，才可以使用 forEach 
let pList = document.querySelectorAll('p');
Array.from(pList).forEach(item => {
  console.log(item);
})

// 将字符串转为数组
Array.from('hello') // ['h','e','l','l','o']
```

### Array.of()

> Array.of方法用于将一组值转换为数组.

```js
Array.of(3,11,8) // [3,11,8]
Array.of(3)  // [3]
```

### 数组实例copyWithin( )

> 在当前数组内部将指定位置的成员复制到其他位置。（会覆盖原有成员），然后返回当前数组。 （修改原数组）

`Array.prototype.copyWithin(target,start,end)`

接收三个参数：

* target：从该位置开始替换数据
* start（可选）: 从该位置开始读取数据，默认为0.如果为负值，表示倒数。
* end (可选)：到该位置前停止读取数据，默认等于数组长度，如果为负值，表示倒数。

```js
let res = [1, 2, 3, 4, 5].copyWithin(0, 4);
console.log(res); //(5) [5, 2, 3, 4, 5]

[1, 2, 3, 4, 5].copyWithin (0, -2, -1) 
 //(5) [4, 2, 3, 4, 5]

```

### 数组实例的 entries()  keys() values()

> entries()  keys() values() 都是用来遍历数组的。entries() 是对键值对的遍历，keys()是对键的遍历，values( ) 是对值的遍历。





### delete

删除数组元素  除了  pop shift之外，还可以用 delete 运算符

```js
 var a = [1, 2, 3];
    delete a[1];
    console.log(a);

// 结果  
(3) [1, empty, 3]
0: 1
2: 3
length: 3

// 可以看出 索引为1的元素已经删除，值为undefined, 但是数组的length并没有改变 
```

### 遍历

使用for循环遍历数组  如 将一个对象的值都遍历到数组中

```js
 var obj = {
      name: 'abin',
      age: 18,
      gender: '男'
    }
    var keys = Object.keys(obj);
    console.log(keys);  ['name', 'age', 'gender']
    var resultArr = [];
    for (let i = 0; i < keys.length; i++) {
      let attr = keys[i];
      resultArr[i] = obj[attr]
    }
 console.log(resultArr); // ['abin', 18, '男']
```

假设数组是非稠密数组，即存在 null  undefined 和不存在的值 ，可选择加判断条件 。

如果 想跳过 null  undefined 和不存在的元素， `if( !arr[ i ] ) continue ;` 

如果 想跳过 undefined 的值   `if(a[i] === undefined) continue ;`  

如果只想跳过不存在的元素，而仍然要处理存在的null  undefined  `if( !(i in arr)) continue;`

### 数组方法

1. join(  )

   将**数组中所有元素**都**转化为字符串**并连接在一起，返回最后生成的字符串。可以指定一个可选字符串在生成的字符串中来分隔数组中的每个元素，如不写则默认以逗号分隔。

2. **reverse( )**

   将数组中的元素颠倒顺序，返回逆序的数组。

3. **sort ( )**

   将数组中的元素排序并返回排序后的数组。**若不带参数，则默认以字母顺序排序**。  如果数组中有undefined， 则自动排到最后。

   同时我们可以指定两个参数 a,b 来决定 元素排序方式 从小到大/从大到小 

   ```js
   a.sort(function(a,b){
   	return a-b // 从小到大 
   })
   ```

4. concat（）

   创建并返回一个新数组，将原始数组 和concat（）中的每个参数进行连接。

   需要注意的是 ：concat( ) 不会递归扁平化数组的数组。 且concat不会修改原数组。 

   ```
   var a=[1,2,3];
   a.concat(4,[5,[6,7]])   // 返回 [1,2,3,4,5,[6,7]]  
   ```

5. slice( ) 

   返回指定数组的一个片段或子数组。 他的两个参数分别指定了要截取的开始位置和结束位置。同时，返回的数组不包含结束位置的数值。

   **不会修改原数组**

6. splice  

   不同于 slice , 它可以 **插入数据，删除数据**，有三个参数，第一个参数指定了 插入和删除的起始位置，第二个参数指定了应该从数组中删除的元素的个数，第三个参数指定了 要插入的元素， 但是重要的一点是  **它会修改原数组** 

7. find( )

   返回数组中满足条件第一个元素的值。否则返回 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。

   ```js
   const array1 = [5, 12, 8, 130, 44];
   const found = array1.find(element => element > 10);
   console.log(found);  // 10 
   
   // 另一种     有大括号就必须加 return  
   let fount = array1.find(function(element,index){
     return element > 10 
   })
   
   ```

8. findIndex( )

   数组中满足条件函数的第一个元素的**索引**，没有找到对应元素则返回-1。

   ```js
    let index = arr.findIndex(item => {
         return item.id === 0
       });
   // 简写
   let index = arr.findIndex(item=> item.id === 0)
   ```

9. flat( [depth])

   将多维数组转为一维数组  depth为数组深度

   ```js
   var arr = [
         ['小刚', '18'],
         ['小明', '20']
       ]
    console.log(arr.flat()); // ['小刚', '18', '小明', '20']
   ```

10. fill( )  填充数组，同时可以指定 从哪个位置开始填充 fill(' ', index) 

    ```js
    let arr=[0,1,2,3,4];
    arr.fill('a')
    console.log(arr)
    ```

## 字符串

### includes()  startsWith() endWith()

includes（）：返回布尔值，表示是否找到了参数字符串。

startsWith( ) :  返回布尔值，表示参数字符串是否在源字符串的头部，

endsWith( ) : 返回布尔值，表示参数字符串是否在源字符串的尾部。

```js
var s='hello world!';
s.startsWith('hello')  // true
s.endsWith('!') // true 
s.includes('o') // true 
```

同时以上这三个方法接收第二个参数，即表示从n位置开始搜索

```js
var s='hello world!';
s.startsWith('world',6)  // true  从下标为n的位置开始到结束
s.endsWith('hello',5) // true    // 与其他两个方法不同，本方法表示前n个字符
s.includes('hello',6) // false  从下标为n的位置开始到结束
```

### padStart()  padEnd()

> 字符串不全，如果某个字符串不够指定长度，会在头部/尾部 进行补全。

需要传递两个参数 ，第一个参数表示字符串的最小长度，第二个参数表示用来补全的字符串。

若超过指定长度，则将补全字符串截取一部分。

```js
 var result = 'world'.padStart(10, 'hello');
 console.log(result);  // helloworld
```

用途：

1. 为数值补全指定位数。

   ```JS
   '1'.padStart(10,'0') // '0000000001
   ```

2. 提示字符串格式.

   ```js
   '12'.padStart(10,'YYYY--MM-DD')
   ```

   



### 作为数组的字符串

字符串的行为类似于 只读的数组 ，即我们 可以通过 **方括号[索引]  /  charAt(0)** 来访问单个字符。

通用的数组方法可以应用到字符串上。 如 join  filter 

```js
let s = 'Javascript';
let result = Array.prototype.join.call(s, ' ');// J a v a s c r i p t

let s = 'Javascript';
let result = Array.prototype.filter.call(s, function (x) {
  return x.match(/[^aeiou]/)
}).join(" ");
console.log(result);  // J v s c r p t 

注意！当把字符串当作数组看待时，他们是只读的。如push sort reverse splice 等数组方法会修改数组，他们在字符串上是无效的。
```

## 函数

### 函数名的定义 

1. **多以 动词或者动词为前缀的词组 来定义函数**，提高代码可读性。

2. 当函数名包含多个单词时，一种情况是 以 下划线 分隔，另一种是  除首个单词外的其他单词 首字母大写。

3. **当函数是内部函数或者私有函数，函数名通常以下划线为前缀。**

4. 对于经常调用的函数，我们可以指定短函数名。

### 函数参数的默认值

默认值直接写在参数定义的后面。

```js
 // 参数变量是默认声明的，不能用let或 const 再次声明 
// 参数的变量不可相同 
function log(x, y = 'world') {
      return [x, y]
    }
    console.log(log('hello')); // ['hello', 'world']
    console.log(log('hello', 'Abin')); // ['hello', 'Abin']
    console.log(log('hello', '')); // ['hello','']
```

这样做既有利于代码的阅读 而且 有利于 将来的代码优化，即使参数不传也不会报错。

### 参数默认值的位置

通常情况下，定义了默认值的参数应该是函数的尾参数，容易看出省略了哪些参数。如果非尾部的参数设置默认值，这个参数传参是无法省略的。

```js
function f(x=1,y){
  return [x,y];
}
f(); // [1,undefined]
f(2); // [2,undefined]
f(,1) // error 报错
f(undefined,1) // [1,1] // 除非 显示输入 undefined否则报错
```

需要注意的是 函数的length属性 只包括 没有定义默认值的参数个数 

```js
(function(a=0,b,c){}).length  // 2 
```

### rest参数

形式为 ( ...变量名 )，用于获取多余的参数，**存到一个变量数组**中，代替了 arguments (具有length属性的伪数组)。

```js
  function add(x, ...rest) {
      console.log(x); // 1
      console.log(rest); // [2,3,4]
    }
    add(1, 2, 3, 4)
```

**注意！ rest参数只能放在函数参数的最后。** 即 只能是最后一个参数 

### name属性

函数的name属性返回该函数的函数名。

```js
function foo(){}
foo.name // 'foo'
```

如果将一个匿名函数赋值给一个变量，则name属性返回实际的函数名

```js
var f = function(){}
f.name  // ES5中返回一个空字符串 ' '  ， ES6中返回 ‘f’
```

如果将一个具名函数赋值给一个变量，则ES5和ES6都会 返回具名函数原本的名字

```js
const bar = function baz(){}
bar.name  // baz 
```



## **异步函数**

> 在计算量大时间长的操作时，或者不想为等待某个异步操作而阻塞线程执行，就选择异步函数

**同步行为**对应内存中顺序执行的处理器指令。每条指令按照他们出现的顺序执行。且每条指令执行完都能立即获得 存储在系统本地的信息。

如要访问一些高延迟的资源，比如像远程服务器发送请求并等待响应，就会出现长时间的等待。那么这种行为显然不可取，所以需要采用 异步行为。

在以往的异步编程模式中，往往需要 深度嵌套的回调函数（回调地狱）来解决。如果异步返回值又依赖另一个异步返回值。那么就需要嵌套回调。显然会增加代码的复杂度。这就需要 期约（promise）

### 期约Promise

> 目的是为了解决回调地狱即 深度嵌套函数 ，通过new操作符来实例化。

它有三个状态：

1. pending 待定 
2. fulfilled  解决 也叫 resolved 
3. rejected  拒绝  

Promise可以从 pending 转为 fulfilled ，或者从 pending 转为 rejected ，无论转为哪种状态都是不可逆的。期约 的状态不能被外部JS代码修改，即 期约与外部的同步代码隔离。

Promise.resolve( )  实例化一个解决的期约。

```js
// 效果一样 
let p1 = new Promise((resolve,reject)=> resolve());
let p1= Promise.resolve()
// 也可以传入任何值转化为一个期约 
```

Promise.reject( )  实例化一个拒绝的期约并抛出一个异步错误。（这个错误不能被 try / catch 捕获，只能通过过拒绝处理程序捕获 ）

```js
// 效果一样 
let p1 = new Promise((resolve,reject)=> reject());
let p1= Promise.reject()
// 这个拒绝的期约的理由就是传给 Promise.reject() 的第一个参数 
let p = Promise.reject(3);
setTimeout(console.log,0,p)  // Promise<reject> : 3 
```

代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构- 期约的方法。

> 期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果。

1. Promise.prototype.then()

   该方法接收最多两个参数： onResolved处理程序和onRejected处理程序。在期约分别进入“兑现”和"拒绝"状态时执行。

   ```js
   p.then(onFulfilled[, onRejected]);
   
   var p1 = new Promise((resolve, reject) => {
     resolve('成功！');
     // or
     // reject(new Error("出错了！"));
   });
   
   p1.then(value => {
     console.log(value); // 成功！
   }, reason => {
     console.error(reason); // 出错了！
   });
   
   
   
   ```

2. Promise.prototype.catch()

   用于给期约添加拒绝处理程序。这个方法只接受一个参数 ： onReejected处理程序 

   和 Promise.prototype.then(null,  onRejected) 一样 

   ```js
   getJson('/posts.json').then(function(posts){
     // ... 
   }).catch(function(error){
     console.log('发生错误',error);
   })
   ```

3. Promise.prototype.finally()

   在promise结束时，**无论结果是fulfilled或者是rejected，都会执行指定的回调函数。**这为在`Promise`是否成功完成后都需要执行的代码提供了一种方式。

4. Promise.all( )

   用于将多个Promise实例包装成一个新的Promise实例。

   ```js
   var p = Promise.all([p1,p2,p3])d
   
   // p1,p2,p3都是Promise对象的实例，如果不是，就先调用Promise.resolve方法，将参数转为Promise实例。
   // 参数不一定是数组，但是必须具有Iterator接口，且返回的每个成员都是Promise实例 
   ```

   p的状态由p1,p2,p3决定，分成两种情况：

   * 只有p1,p2,p3的状态都变成Fulfilled，p的状态才会变成 Fulfilled，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数。
   * 只要p1,p2,p3中有一个被Rejected,p的状态就变成Rejected,此时第一个被Rejected的实例的返回值会传递给P的回调函数。

5. Promise.race( )

   和 Promise.all( ) 不同的是：

   p1,p2,p3中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值就传递给p的回调函数 

   ```js
   const p = Promise.race([
     fetch('/resource-that-may'),
     new Promise(function(resolve,reject){
       setTimeout(()=>reject(new Error('request timeout')),5000)
     })
   ])
   p.then(response=>console.log(response));
   p.catch(error=>console.log(error));
   
   // 该代码表示 如果5秒之内fetch方法无法返回结果，变量p的状态就会变为Rejected,从而触发catch方法指定的回调函数。
   ```

### Generator

> 执行Generator函数会返回一个遍历器对象，代表Generator函数的内部指针，返回的遍历器对象可以依次遍历Generator函数内部的每一个状态 

存在两个特征 ：

1. function命令与函数名之间有一个星号
2. 函数体内部使用yield语句定于不同的内部状态 ，只有调用next方法才会执行generator函数  

```js
// generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行 
function* mygenerator() {
      yield 'hello',
        yield 'world'
      return 'finish'
    }
    var gen = mygenerator();  
    console.log(gen.next()); // hello 
    console.log(gen.next()); // world
    console.log(gen.next()); // finish 
```

yield语句和return语句异同：

1. yield和return 都能返回紧跟在语句后的表达式的值。
2. 每次遇到yield函数暂停执行，下一次会从该位置继续向后执行，而return语句不具备位置记忆的功能。
3. 一个函数只能执行一次return语句，但可以执行多次 yield语句 

**next方法的参数**

> yield语句本身没有返回值，或者说总是返回undefined。 next方法可以带有一个参数，该参数会被当作上一条yield语句的返回值。

用于在Generator函数运行的不同阶段从外部向内部注入不同的值从而调整函数行为。

```js
 function* foo(x) {
      var y = 2 * (yield(x + 1));
      var z = yield(y / 3);
      return (x + y + z);
    }
    var a = foo(5);
    console.log(a.next()); // value: 6, done: false
    console.log(a.next()); // value: NaN, done: false =》 未传参，所以上一个yield表达式的值为 undefined 2*undefined /3  = Nan
    console.log(a.next()); // value: NaN, done: true
    var b=foo(5);
    console.log(b.next()); // value: 6, done: false
    console.log(b.next(12)); //  value : 8, done : false 
    console.log(b.next(13)); // value: 13+24+5 = 42 
```

注意！！

由于next方法的参数表示上一条yield语句的返回值，所以第一次使用next方法时传递参数是无效的。

### async

> async会为了更好的处理异步操作，是Generator的语法糖 

实例：

```js
var fs = require('fs');
var readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function (error, data) {
      if (error) return reject(error);
      resolve(data);
    })
  })
}

var gen = function*(){
  var f1=yield readFile('/etc/1.text');
  var f2=yield readFile('/etc/2.text');
  console.log(f1.toString());
  console.log(f2.toString());
}
```

将 改成 async函数形式

```js
var fs = require('fs');
var readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function (error, data) {
      if (error) return reject(error);
      resolve(data);
    })
  })
}

var gen =async function(){
  var f1=await readFile('/etc/1.text');
  var f2=await readFile('/etc/2.text');
  console.log(f1.toString());
  console.log(f2.toString());
}
```

观察可以发现，async函数就是将Generator函数的*改成async , yield 改成 await 

async函数对Generator函数的改进体现在4点：

1. 内置执行器 ， async函数的执行与普通函数一样，只要一行
2. 更好的语义， asyncb表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
3. 更广的适用性    yield命令后面只能是Thunk函数或者Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于异步操作 ）
4. 返回值是Promise ，用then来指定下一步操作。

async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

```js
async function getStockPriceByName(name){
  var symbol = await getStockSymbol(name);
  var stockPrice = await getStockPrice(symbol);
  return stockPrice;
}
getStockPriceByName('goog').then(function(result){
  console,log(result)
})
```

**async函数有多种声明形式** 

```js
// 函数声明 
	async function demo(){
  ...
}
// 函数表达式 
	const demo = function(){
  ...
}
// 对象的方法 
	let obj={async foo(){}};
    obj.foo().then(...)
// 箭头函数
   const foo= async()=>{};
```

**返回Promise对象**

async函数内部return语句返回的值，会成为then方法回调函数的参数 

```js
async function f(){
	return 'hello world'
}
f().then(v=>console.log(v))
// "hello world"
```

async函数内部抛出错误会导致返回的Promise对象变为 reject状态。抛出的错误对象会被catch方法回调函数接收到。

```js
async function f(){
  throw new Error('出错了')
}
fn().then(v=>console.loh(v),e=>console,log(e))
// Errror:出错了
```

async函数返回的Promise对象必须等到 内部所有await命令后面的Promise对象执行完毕才会发生状态改变，除非遇到return语句或者抛出错误。

```js
async function getTitle(url){
  let response = await fetch(url);
  let html = await response.text(); 
  return html.match(/<title>([\s\S+])<\/title>/i)[i];
}
getTitle('https://tc39.github.io/ecma262/').then(console.log)
// “ECMAScript 2017  Language Specification” 

// 上面代码中， 函数内部会进行3个操作，抓取网页、取出文本、匹配页面标题。 只有这三个操作全部完成，才会执行then方法里面的console,log 
```

**错误处理**

如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject 

```js
async function f(){
  await new Promise(function(resolve,reject){
    throw new Error('出错了')；
  })
}
f()
.then(v=>console,log(v))
.catch(e=>console,log(e))
// Error:出错了
```

防止出错的方法  将其放在 try..catch代码块之中 

```js
async function f () { 
	try { 
		await new Promise(function (resolve, reject) { 
			throw new Error ’出 错了 ）；
		}) ; 
	} catch (e) { 
	return await (’ hello world ’ ) ;
```

## 原型/原型链

### 函数的原型 

两者比较着看：

prototype : 原型  =》   函数的一个属性

`__proto__` 原型链（连接点）  =》 对象Object的一个属性 

**对象的 `__proto__`  保存着该对象的构造函数的prototype**   



 每个函数都会有一个prototype属性 。即显示原型属性，默认指向一个空的Object对象 

每个实例对象都有一个`__proto__` ,可称为隐式原型

**对象的隐式原型的值为其对应构造函数的显示原型的值** 

<img src="https://gitee.com/youngstory/images/raw/master/img/202110252013455.png" alt="image-20211025201341306"  />

```js
 function Animals() {
      
    }
 var cat = new Animals(); // this指向 实例对象
 console.log(cat.__proto__ === Animals.prototype); // true 
```

```js
 function Animals() {
      this.a = 1;

    }
    var cat = new Animals(); // this指向 实例对象
    Animals.prototype.b = 2;
    Object.prototype.c = 3;
    console.log(cat.a); // 1 
    console.log(cat.b); // 2  自身没有b属性就会沿着原型链往上找
```

Function和 Object 

```js
 console.log(Function.__proto__); // ƒ () { [native code] }
    console.log(Function.prototype); // ƒ () { [native code] } 
    //  Function.__proto__ ===  Function.prototype
    console.log(Object.__proto__ === Function.prototype); // true 
```

### **判断属性是否存在 ？** 

```js
 function Test() {
      this.a = 1;
      this.b = 2
    }
    Test.prototype.c = 3;
    var demo = new Test();
    console.log(demo.hasOwnProperty('c')); // 不包含原型链上的 只是自身属性  
    console.log('c' in demo);  // 包含原型链 
```

constructor  指向实例的构造函数 ，是允许更改的

### **原型链继承**

优点：父类新增方法属性，子类都能访问到，简单易于实现

缺点：**子类的实例共享了父类构造函数的引用属性**  不能传参

```js
// 定义一个动物类 
function Animal(name) {
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function () {
    console.log(this.name + '正在睡觉');
  }

}
// 原型方法
Animal.prototype.eat = function (food) {
  console.log(this.name + '正在吃' + food);
}

// 原型链继承  
// 将父类的实例作为子类的原型 
// 缺点： 子类的实例共享了父类构造函数的引用值(数组 对象等)  不能传参
function Cat() {

}
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

var cat = new Cat();
cat.eat('fish');//cat正在吃fish
cat.sleep();//cat正在睡觉
```

### 构造函数继承

优点：子类构造函数 借用 父类的构造函数   解决了引用值共享的问题

缺点： 没有办法拿到原型上的方法；

```js
 // 由于原型链继承  Cat.prototype = new Animals()  存在引用共享的问题 所以 采用构造函数 
    // 借用构造函数继承  
    function Animals() {
      // this.a = 1;
      this.a = [1, 2, 3, 4, 5]
    }
    Animals.prototype.say = function () {
      console.log('会叫');
    }

    function Cat() {
      Animals.call(this);
    }

    var cat1 = new Cat();
    var cat2 = new Cat();
    cat1.a.push(6);
    console.log(cat1.a); // 1 2 3 4 5 6
    console.log(cat2.a); // 1 2 3 4 5
```

### **组合继承**（伪经典继承）

优点：可传参   

缺点：调用了两次父类的构造函数，造成了不必要的消耗

```js
// 组合继承
// 构造函数继承+ 原型链继承 
// 缺点： 调用了两次父类的构造函数，造成了不必要的消耗，父类方法可复用 
// 优点可传参，不共享父类引用属性 
    function Animals() {
      // this.a = 1;
      this.a = [1, 2, 3, 4, 5]
    }
    Animals.prototype.say = function () {
      console.log('会叫');
    }

    function Cat() {
      Animals.call(this);
    }
    Cat.prototype = new Animals();
    var cat1 = new Cat();
    var cat2 = new Cat();
    console.log(cat1);
    cat1.a.push(6);
    cat1.say() // 会叫
    console.log(cat2.a); // 1 2 3 4 5
```

### **寄生组合继承**（经典继承）

优点：可传参，不会创建多余的实例占用内存 ，可通过Object.assign实现多继承

缺点：

```js
// 寄生组合继承 
function Cat(name,age){
  Father.call(this,name);
  this.age=age
}
Cat.prototype=Object.create(Animal.prototype)
Cat.prototype.constructor=Cat
var cat = new Cat('MING', 20)
console.log(cat);
```

### **ES6的extend**

```js
class Animal {
	constructor (name) {
	this.name = name
	}
	showName () {
		alert(this.name)
	}
}
class Cat extends Animal {
	constructor (name) {
		super(name)
	}
	sayMy () {
		super.showName()
	}
}

```

## 客户端JS

> window对象是所有客户端JavaScript特性和API的主要接入点,表示一个窗口/窗体。 可以用 标识符window来引用它 ！ 

window下的重要属性 ：

1. location 指定当前显示在窗口中的URL

   ```js
   window.location = 'http://baidu.com'
   ```

2. document  文档， 常用于JS操作 DOM 

   ```js
   document.getElementsByClassName('btn')[0];
   ```

3. onload处理函数

   当显示在窗口中的文档内容稳定并可以操作时会触发它！ 

   ```js
   window.onload=function(){
   		// 代码
   }
   ```

### 多窗口和窗体

一个web浏览器窗口可能在桌面上包含多个标签页。每一个标签页都是独立的”浏览上下文，每一个上下文都有独立的window对象，而且相互之间互不干扰。

**打开窗口**

Window.open( )  载入指定的URL到新的或已存在的窗口中，并返回代表那个窗口的Window对象 。

可选参数有4个 ：

1. 要在新窗口显示的文档的URL ，省略则 使用 空白页 about:blank
2. 新打开的窗口的名字。 若该名字存在即直接使用已存在的窗口。省略参数默认 _blank
3. 以逗号分割的列表，包含大小和各种属性 
4. 该参数只在第二个参数命名的是一个存在的窗口时才生效，声明了由第一个参数指定的URL是应用替换掉窗口浏览历史的当前条目（true）,还是在窗口浏览历史中创建一个新的条目（false） 默认为 false 

```js
 window.open('http://www.baidu.com', 'baidu', 'width=400,height=400,status=yes,resizable=yes')
```

**关闭窗口**

window.close( )  

即使一个窗口关闭了，代表它的window对象仍然存在，已关闭的窗口会有个值为true的closed属性，它的document会是null.

### 脚本化文档

**1. 查询元素的几何尺寸**

**使用getBoundingClientRect**()  可以判定一个元素的尺寸和位置 。 

![image-20211228104157444](https://gitee.com/youngstory/images/raw/master/img/202112281041534.png)

其中： left 和 top 表示元素的左上角的X和Y坐标，right和bottom 表示元素的右下角的X和Y坐标 

**2.滚动** 

滚动浏览器到文档最下面的页面可见：

```js
// 获取文档和视口的高度 
let documentHeight = document.documentElement.offsetHeight;
let viewportHeigth = window.innerHeight;
window.scrollTo(0, documentHeight - viewportHeigth)
```

# ES2020

## ?? 双问号

在双问号的左边如果是`null，undefined`时，就返回右边的值，如果没有就返回左边的值。

与 || 语法相同，不同的是，左边满足 false条件，返回右边的值。

```js
const foo = null ?? 'myschool'
// myschool
```

# 前端工程化

## 四步走

- 模块化 (js的模块化，css的模块化，资源的模块化)

- 组件化（复用现有的UI结构，样式，行为）

- 规范化 （目录结构的划分，编码规范化，接口规范化，文档规范化 git分支管理）

- 自动化 （自动化构建，自动部署，自动化测试 ）

## 工具 

- webpack  提供了友好的前端模块化开发支持，以及代码压缩混淆。处理浏览器js的兼容性 ，性能优化

- parcel   一款0配置的打包工具,而且直接使用即可,打包速度快,Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。

- MVC 

  - Model（模型） - 模型代表一个存取数据的对象     

  - View（视图） - 视图代表模型包含的数据的可视化, 也就是我们看到的页面    

  -  Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。

  - 典型的框架就是 java领域的 Spring  Structs   Hibernate ![img](https://api2.mubu.com/v3/document_image/48a3a2b8-bef1-472c-bfab-738b6346d62f-2519832.jpg)![img](https://api2.mubu.com/v3/document_image/29a2c0ae-6b49-4c8c-ba2b-407d012c7fa6-2519832.jpg)

- MVVM

  - 在MVVM框架下视图和模型是不能直接通信的，只能通过ViewModel进行交互，它能够监听到数据的变化，然后通知视图进行自动更新，而当用户操作视图时，VM也能监听到视图的变化，然后通知数据做相应改动，这实际上就实现了数据的双向绑定。并且V和VM可以进行通信。![img](https://api2.mubu.com/v3/document_image/1fc7b8e5-608c-438c-82b6-6e051c03d4af-2519832.jpg)

  - ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

  - MVVM与MVC的最大区别就是：它实现了View和Model的自动同步，也就是当Model的数据改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变数据后该数据对应View层显示会自动改变。

