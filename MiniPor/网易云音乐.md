# 介绍

仿网易云音乐的一款微信小程序，在微信小程序开发工具中编码。

技术选型： 本地Node服务器 + 网易云开放接口API

# 功能实现

## 首页

渲染banner数据时，需要用wx:for ，同时需要注意 **image 的 src** 前面不需要加 `:`  不要和vue混肴

```js
 <swiper-item wx:for="{{bannerData}}" wx:key="index">
      <image src="{{item.pic}}"></image>
 </swiper-item>
```

在 wx-for  时，如果需要**嵌套循环遍历**，我们可以 使用 wx:for-item='' 来指定 子循环的item 

```js
 <swiper-item wx:for="{{topListData}}" wx:key="item" >
       <view class="title">{{item.name}}</view>
       <view class="musicItem" wx:for="{{item.tracks}}" wx:key="item" wx:for-item="music" >
        <image src="{{music.al.picUrl}}"></image>
        <text class="count">{{index+1}}</text>
        <text class="songName">{{music.ar[0].name}}</text>
       </view>
        
  </swiper-item>
```

## 我的页面

### 手指滑动效果

给要设置滑动效果的view容器 设置 手指滑动 三件套 `bindtouchstart` ` bindtouchmove`    `bindtouchend`

```html
  <view
    class="cover-container"
    bindtouchstart="handleTouchStart"
    bindtouchmove="handleTouchMove"
    bindtouchend="handleTouchEnd"
    style="transform: {{coverTransform}};transition: {{coverTransition}}"
  >
```

在 js文件 进行 逻辑处理： 

1. 定义 手指的开始滑动坐标，结束滑动坐标， 滑动距离变量

   ```js
   let startY = 0;//手指起始坐标
   let moveY = 0;//手指移动坐标
   let moveDistance = 0;//手指移动距离
   
   
   data: {
       coverTransform: 'translateY(0)',
       coverTransition: '',
    },
   
   ```

2. 通过 event  事件 拿到 坐标值 clientY ,计算出移动距离，动态更新 transform 属性

   ```js
     handleTouchStart(event){
       this.setData({
         coverTransition: ''
       })
       //起始手指坐标
       startY = event.touches[0].clientY;
     },
     handleTouchMove(event){
       moveY = event.touches[0].clientY;
       moveDistance = moveY - startY;
   
       if(moveDistance <= 0){
         return;
       }
       if(moveDistance >= 80){
         moveDistance = 80;
       }
   
       //动态更新coverTransform
       this.setData({
         coverTransform: 'translateY('+moveDistance+'rpx)'
       })
     },
   ```

   

3. 滑动结束后，恢复默认值（translateY(0)）。

   ```js
   handleTouchEnd(){
           //重置coverTransform
           this.setData({
             coverTransform: 'translateY(0)',
             coverTransition: 'transform 1s linear'
           })
     },
   ```

## 视频页面

1. 给scroll-view 设置一个 滚动效果 

   首先要保证 值应为某子元素id（**id不能以数字开头**） ,  `scroll-with-animation` 为滚动添加过渡效果 

   ```js
   	// navId 是鼠标点击某一个item，把item的id 设为了data中的 navId,
   
   <scroll-view 
       scroll-into-view="{{'scroll'+ navId}}"  scroll-with-animation>
          <view id="{{'scroll'+item.id}}">
             <view>
               {{item.name}}
             </view>
          </view>
   </scroll-view>
   ```

2. 同一个页面只允许有一个视频播放 

   解决思路:

   1. 在点击播放的事件中，需要找到上一个播放的视频
   2. 在播放新视频的时候，把上一个视频暂停  
   
   解决方法： 通过wx.createVideoContext（id） 来为点击的视频创建 实例对象，参数为 视频的唯一id 
   
   ```js
     <video src="{{item.data.urlInfo.url}}" 	show-center-play-btn='{{false}}' id="{{item.data.vid}}" 	bindplay='handleVideo'></video>
     
    
      handleVideo(event){
       let vid = event.currentTarget.id;
        this.vid !== vid && this.videoContext && this.videoContext.stop();
     this.vid=vid;
        this.videoContext= wx.createVideoContext(vid);

     },
   ```
   
3. 视频优化，同一个页面放多个视频容易产生卡顿，所以我们可以初次渲染时显示视频的封片图片，点击图片话，将其替换为video组件。

   解决方法：

   ```js
    // 图片和视频 共用 id 和样式 处理函数
   // 当捕获到用户点击的 id 和 item的id 相同时，让他显示 视频组件，其他的都 显示 图片组件 
    <view class="videoItem" wx:for="{{videoList}}" wx:key="item">
             <video wx:if='{{videoId === item.data.vid }}'class="common" src="{{item.data.urlInfo.url}}" 	show-center-play-btn='{{false}}' id="{{item.data.vid}}" 	bindplay='handleVideo' ></video>
             <image wx:else class="common"  src="{{item.data.coverUrl}}" id="{{item.data.vid}}" bindtap="handleVideo"></image>
    </view>
   
   // 点击事件处理函数
   handleVideo(event){
       let vid = event.currentTarget.id;
        this.vid !== vid && this.videoContext && this.videoContext.stop();
        this.vid=vid;
        this.setData({
          videoId:vid
     })
   
        this.videoContext= wx.createVideoContext(vid); // 视频实例化
        this.videoContext.play();// 点击视频后，自动播放
   
     },
   
   ```

4. 视频滚动时，导航栏固定位置不变

   解决思路： 给 视频组件的 scroll-view 设置 高度 ，如何计算呢 ？

   方法：

   ```js
   // 利用 css3新特性 calc 来计算  
   // 注意！ 使用 calc 时 ， - 左右要有空格
   .videoScroll {
     height: calc(100vh - 160rpx)  // 1vh 等于 1% 的可视窗口高度 
   }
   ```

5. 视频自动从上次播放的位置 开始播放 

   思路：新建一个数组用来保存每个视频的id和  currentTIme即播放时间，每次用户点击视频，先看看该视频ID 是否存在于这个数组中，然后 通过 api   seek跳转到对应的位置播放 

   ```js
    <video id="{{item.data.vid}}" bindtimeupdate="videoTimeHandle" bindplay='handleVideo' ></video>
    
   // 创建 视频播放的记录数组 
     videoTimeHandle(event){
         let videoTimeObj={vid:event.currentTarget.id,currentTime:event.detail.currentTime};
         let {videoUpdateTime} = this.data;
         let videoItem =  videoUpdateTime.find(item=>item.vid === videoTimeObj.vid );
         if(videoItem){
           videoItem.currentTime= videoTimeObj.currentTime;
         }else{
           videoUpdateTime.push(videoTimeObj);
         }
         this.setData({
           videoUpdateTime
         })
         
     },
     
     // 用户点击视频 的事件函数 
     handleVideo(event){
       let vid = event.currentTarget.id;
     /*    this.vid !== vid && this.videoContext && this.videoContext.stop();
        this.vid=vid; */
        this.setData({
          videoId:vid
        })
   
        this.videoContext= wx.createVideoContext(vid); // 视频实例化
        let { videoUpdateTime } = this.data;
       
        let videoItem = videoUpdateTime.find(item=>item.vid === vid);
        if(videoItem){
         this.videoContext.seek(videoItem.currentTime)
        }
       
        this.videoContext.play();// 点击视频后，自动播放 `
   
     },
       
       
   // 视频播放完后，我们要及时的从播放记录中删除  
   // 通过video 组件添加  bindended="handleVideoEnd"    
       
   handleVideoEnd(event){
       let videoEndId = event.currentTarget.id;
       let { videoUpdateTime } = this.data;
       videoUpdateTime.splice(videoUpdateTime.findIndex(item=>item.vid === videoEndId),1);
       this.setData({
         videoUpdateTime
       })
   },
   
   ```

## 歌曲推荐页面

1. 接收到的数据是 【object,Object】如何解决？

   因为在 url地址中，是不能有js对象或者数组的。所以需要通过JSON.stringify() 转换成字符串传输，再用 JSON.parse() 解析 

2. 错误提示 `Unexpected end of JSON input`   说明 传输的 JSON数据是 错误的。原生小程序的传参长度有限制。



## 登录页面

设计 账户 密码输入   基本布局   同时给定 两个输入框 同一个事件处理函数  **bindinput**

```html
 <view class="input-content">
      <view class="input-item">
        <text class="tit">手机号码:</text>
       
        <input type="text" placeholder="请输入手机号码" data-test="abc" data-type="phone" id="phone" bindinput="handleInput"/>
      </view>
      <view class="input-item">
        <text class="tit">密码:</text>
        <input type="password"  placeholder="请输入密码" data-test="abc" data-type="password" id="password" bindinput="handleInput"/>
      </view>
    </view>
```

初始化 用户名/密码 

```
  data: {
    phone: '',//手机号
    password: ''//密码
  },
```

但是为了 区分 是 用户名/密码。我们需要用`id` 属性来区分 ，并通过 `event.detail.value`来获得输入的值 

```
  handleInput(event){
    let type = event.currentTarget.id;
    this.setData({
      [type]: event.detail.value
    })
  },
```

将 用户名/密码进行 正则表达式验证 并发起请求 

```css
async login(){
    //得到数据
    let {phone,password} = this.data;
    //验证
    //手机号不为空
    if(!phone){
      wx.showToast({
        title: '手机号不能为空',
        icon: 'none'
      })
      return;
    }
    //正则验证是一个手机号
    //正则表达式
    let phoneReg = /^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$/;
    if(!phoneReg.test(phone)){
      wx.showToast({
        title: '手机号格式错误',
        icon: 'none'
      })
      return;
    }
    //密码不为空
    if(!password){
      wx.showToast({
        title: '密码不能为空',
        icon: 'none'
      })
      return;
    }
    //后端验证
    let result = await request('/login/cellphone',{phone,password,isLogin:true});
    if(result.code === 200){
      wx.showToast({
        title: '登陆成功',
      })
      //存储个人信息
      wx.setStorageSync('userInfo', JSON.stringify(result.profile))
      //从登录页返回个人中心页
      wx.reLaunch({
        url: '/pages/my/my'
      })
    }else if(result.code === 400){
      wx.showToast({
        title: '手机号错误',
        icon: 'none'
      })
    }else if(result.code === 502){
      wx.showToast({
        title: '密码错误',
        icon: 'none'
      })
    }else{
      wx.showToast({
        title: '登陆失败，请重新登录',
        icon: 'none'
      })
    }

  },
```



# 注意事项

1. 小程序 发起请求 必须 用 https协议 ，最大并发限制10个  

2. 在发起 localhost: 3000/banner 请求时，报错 ！http://localhost:3000 不在以下request合法域名列表中。

   解决方式：服务器须备案  

   1. 登录小程序  [(小程序.com)](https://mp.weixin.qq.com/wxamp/devprofile/get_profile?token=592424894&lang=zh_CN) 进行服务器配置  并且 最多 二十个域名 
   2. 若没有服务器则 可以 选择  点击详情页 选择  不检验合法域名 

   ![image-20211201102306352](https://gitee.com/youngstory/images/raw/master/img/202112011023168.png)

3. **真机调试**  动态数据 显示不出来的问题

   解决方法 ： 内网穿透  **通过外网域名 访问你的内网 127.0.0.1**   

   工具  ： utools的 内网穿透工具 

4. 通过id 向 event 传值时，会**自动将 number数据 转换成string 类型**。

   ```js
    // id="{{item.id}}">   id是 number数据类型（原有类型）
     
     <view class="navContent {{item.id === navId ? 'active' : ''}} " bindtap="changeNav" id="{{item.id}}">
     </view>
     
     // js 点击事件中
       changeNav(event){
       let navId = event.currentTarget.id;  // 会将number转换成 string 
       this.setData({
         navId:navId  
       })
     },
   ```

   解决方法：

   1.    navId:navId*1   
   2.    或者用位移   navId:navId>>0 
   3.  用 `data-id` ="{{item.id }}" 来传值， 用 `event.currentTarget.dataset.id` 来 取值 