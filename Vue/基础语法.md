# Vuex

>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。可以很方便的实现组件之间的数据的共享。

注意：

只有组件之间共享的数据，才有必要存储到vuex中，组件中的私有数据，依旧存储到自身的data中即可。

Vuex基本结构：

```js
import Vue from "vue";
import Vuex from "vuex";

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
  },
  mutations: {
    
  },
  actions: {},
  modules: {},
});
```

## state

> 存放公共数据。所有共享数据都要统一放到Store中的State中 

```js
 state: {
    count: 2
 },
```

组件访问State中数据的第一种方式：

```js
// 在 template区域中this可以省略 

this.$store.state.全局数据名称
```

第二种方式：

```js
1. 从Vuex中按需导入 mapState函数
import {mapState} from 'vuex'
2. 通过导入 mapSate 函数，将当前组件所需的公共数据 映射到 当前组件的计算属性 computed中
computed: {
    ...mapState(['count']),
},
```

而**修改state中的数据**就要用到 `Mutations`

## Mutations

>用来修改 State中的数据 。  但不支持异步修改

优点：

1. 可以集中监控所有数据的变化
2. 减少 直接操作 Store的数据

使用：

```js
mutations: {  // 选择性 添加参数 
    inc(state, step) {
      state.count += step;
    },
    dec(state, step) {
      state.count -= step;
    }
  },
```

触发mutation的第一种方式 ：

```js
// 在组件 methods 中通过 commit 来触发 mutation
methods: {
    add() {
      this.$store.commit('inc', 2)
    },
    dec() {
      this.$store.commit('dec', 2)
    },
},
```

第二种方式 ：

```js
// 组件中导入 
import { mapMutations } from 'vuex'
// 将导入的函数 映射到 methods中
methods:{
   ...mapMutations(['sub']),
}
// 在template中 click的事件函数中使用 sub方法 , 参数可传可不传
  methods: {
    ...mapMutations(['sub']),
    handlesub() {
      this.sub(3)
    },
  },
}

```

## Actions

> 用来处理异步任务 。 通过触发Mutation的方式间接变更数据 。不能直接修改state中的数据

异步执行的第一种方法：

```js
// 要异步执行的 mutation
 mutations: {  // 只准许写 同步代码  
    sub(state, step) {
      state.count += step;
    }
  },
// 定义actions函数，写事件 
// 通过 context.commit 进行触发 mutation中的函数 
 actions: {
    asyncsub(context, step) {
      setTimeout(() => {
        context.commit('sub', step)
      }, 2000)
    }
 },
 // 组件中绑定 asysub 发送 ，由dispatch触发actions中的异步函数  
   asysub() {
     this.$store.dispatch('asyncsub', 10)
   },
```

第二种方法：（和mapMutation ， mapState雷同）

```js 
// 1. 导入 mapActions 函数
import {  mapActions } from 'vuex'
// 2.methods中映射 mapActions
...mapActions(['asyncsub']),
// 3. 组件绑定点击事件，调用actions函数 
 mapsub() {
  this.asyncsub(10)
},
```

## Getter

> Getter用于对Store中的数据进行加工处理形成新的数据。类似于计算属性

**注意：**

Store中的数据发生变化，Getter的数据也会跟着变化。

**使用：**

```js
// 1.vuex中定义 getters函数
 getters: {
    newNum: state => {
      return `当前最新的数据是${state.count}`
    }
  },
    
// 2.组件中使用它！！ 
   this.$store.getters.newNum

// 使用它的第二种方式是导入并映射
import {  mapGetters } from 'vuex'
// 在computed中进行映射 getters函数
 computed: {
    ...mapState(['count']),
    ...mapGetters(['newNum']),
  },
```

## Modules

> 顾名思义就是 将 store分割成模块，每个模块都拥有自己的state,mutation，action，getter 。解决了过多配置放入单一状态文件臃肿的问题。

在 store文件下新建一个modules文件夹用来存放我们的各个modules

以 carsList 为例：s

```js
// carsList.js
const state = {
  carsList: [],
};
const mutations = {
  changeCarsList(state, value) {
    state.carsList = value;
  },
};
export default {
  namespaced: true,
  state,
  mutations,
};
```

然后在 store文件夹下主文件 index.js中引入 

```js
import carsList from "./modules/carsList"
export default new Vuex.Store({

  modules: {
    carsList,
  }

});
```

# Vue插槽

> 作用： 占位置

# Vue动画

> Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 

## 组件的过渡

我们可以 使用 Vue提供的 `transition` 封装组件，来给我们的元素添加动画 / 过渡

多应用于以下几种情况：

- 条件渲染 (使用 `v-if`)
- 条件展示 (使用 `v-show`)
- 动态组件
- 组件根节点

**demo实例：**

```js

<transition name="fade">
    <p v-if="show">hello</p>
  </transition>
```

```js
.fade-enter-active, .fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}
```

## 过渡的类名

在进入/离开的过渡中，会有6个class切换 。

1. `v-enter`：定义进入过渡的开始状态。
2. `v-enter-active`： 在元素被插入之前生效，在过渡/动画 完成之后移除。
3. `v-enter-to` : 定义进入过渡的结束状态。 同时 v-enter移除 
4. `v-leave`： 定义离开过渡的开始状态 
5. `v-leave-active`： 定义离开过渡生效时的状态。
6. `v-leave-to`： 定义离开过渡的结束状态 。 

![image-20220106101906649](https://gitee.com/youngstory/images/raw/master/img/202201061019982.png)

## 常用的过渡/动画代码

```js
// 设置持续时间和动画函数  
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to
/* .slide-fade-leave-active for below version 2.1.8 */ {
  transform: translateX(10px);
  opacity: 0;
}
```

CSS动画

```css
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}
```

# 生成二维码

采用的是 vue-qr 插件 [Binaryify/vue-qr: The Vue Component for Awesome-qr.js (github.com)](https://github.com/Binaryify/vue-qr#readme)

### 导入

npm install vue-qr --save

import VueQr from 'vue-qr'

### 使用

```js
 <vue-qr ref="qrcode" :correctLevel="3" :autoColor="false" colorDark="#313a90" :logoSrc="logoSrc" :text="codeUrl" :size="95" :margin="0" :logoMargin="3"></vue-qr>


export default {
  components:{
    VueQr
  },
   data () {
    return {
      logoSrc: require('../assets/personalLogo.jpg'),
      codeUrl: '张露文我爱你'
    }
  },
}

```

### 可选参数

| ext       | 二维码要展示的内容                                           |
| --------- | ------------------------------------------------------------ |
| logoSrc   | 二维码中间的小logo                                           |
| logoScale | 小logo的大小（别搞太大，超过容错率识别不出来的）             |
| size      | 整个二维码所占空间的大小，（宽高相等，包含margin） 可能需要你自己用css设置一下图片宽高100% |
| margin    | 二维码的外边距（默认 20px）                                  |

### 下载二维码

思路： 创建a标签元素，将当前图片地址赋给 a标签的 href 链接地址

```js
 downloadQR(){
     const a = document.createElement('a');
     a.download='二维码',
     a.href= this.$refs.qrcode.$el.src // $el 所有的组件都有一个属性$el: 用于获取组件中的元素 
     a.click()
   }
  }
```



